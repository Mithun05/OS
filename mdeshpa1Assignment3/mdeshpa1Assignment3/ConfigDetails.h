
 /**
 * The ConfigDetails header source file defines a structure. 
 * The Structure holds a buffer which acts as a FIFO queue
 * to store number of lines specified as a module parameter on the command line
 * and synchronization primitive to prevent race condition and deadlock.
 */

#ifndef CONFIGDETAILS_H
#define CONFIGDETAILS_H

 /**
  * The standard header files 
  */
 #include <linux/init.h>                 // Macros used to mark up functions e.g __init __exit
 #include <linux/module.h>               // Core header for loading module into the kernel
 #include <linux/miscdevice.h>           // Header file to support Misc Kernel Driver Model
 #include <linux/kernel.h>               // Contains types, macros, functions for the kernel     
 #include <linux/fs.h>                   // Header for the Linux File System Support
 #include <asm/uaccess.h>                // Required for copy from kernel to user space buffer function support
 #include <linux/string.h>               // Header for string functions support
 #include <linux/sched.h>                // Header file
 #include <linux/slab.h>                 // Header file
 #include <linux/moduleparam.h>          // Header file for Kernel module to have parameter as a command line argument
 #include <linux/semaphore.h> 		 // Header file to include synchronization primitive 

 /**
 * Kernel Module Information 
 */
 MODULE_LICENSE("GPL");                         	 // The license type -- Avoid kernel taints warning     
 MODULE_AUTHOR("Mithun Deshpande");                      // The author       -- visible when you use modinfo
 MODULE_DESCRIPTION("A simple Misc Linux Char Driver");  // The description  -- see modinfo
 MODULE_VERSION("3.0");                                  // The version no   -- to inform users
 
 /**
  * Configuration Data Structure
  */
 typedef struct ConfigData {

	char **lineItem;		// Store lines generated by producer i.e FIFO queue
	struct semaphore semOneMutex;	// Acts as a reader mutex
	struct semaphore empty;		// Counts empty buffer slots
	struct semaphore full;		// Counts full buffer slots
	struct semaphore semTwoMutex;	// Acts as a writer mutex

 } ConfigData;

 /**
 * Char driver name
 */ 
 #define CHAR_DRIVER "linepipe"


 /**
  * Max Line Size : Line generated by producer
  */
 #define LINE_SIZE 100

 /**
 * The Variable used to hold Buffer size - Queue Size
 */
 static int N = 0;

 /**
 * The Counting variable used to hold items inserted into the queue
 */
 static int insertQueue = 0;

 /**
 * The Counting variable used to hold items removed from the queue
 */ 
 static int removeQueue = 0;

 /**
 * The Variable used to keep track of how many items inserted or removed from the queue
 */ 
 static int trackQueue = 0;

 /**
 * The Variable used to deal with an error scenerio. 
 */
 int error;

 /**
  * Module Parameter Initialization and description
  */
 module_param(N, int, 0000);
 MODULE_PARM_DESC(N, "Queue Size");

 /**
  * The Prototype functions for the character driver
  */
  static int     device_open(struct inode *, struct file *);
  static int     device_close(struct inode *, struct file *);
  static ssize_t device_read(struct file *, char *, size_t, loff_t *);
  static ssize_t device_write(struct file *, const char *, size_t, loff_t *);

 /** 
 *   @brief Devices are represented as file structure in the kernel. The file_operations structure from
 *   /linux/fs.h lists the callback functions that you wish to associated with your file operations
 *   using a C99 syntax structure. char devices usually implement open, read, write, release and
 *   lseek calls
 */
 static struct file_operations fops = {
        .open = device_open,                    // open  device operation
        .read = device_read,                    // read  device operation
        .write = device_write,                  // write device operation 
        .release = device_close                 // close device operation
 };

 /**
 * @brief Misc Device representation. Each device is associated with the minor and major number.
 * All misc device share the common major number which is 10. The minor number gets dynamically. 
 * And provide the device name to create with the operations specified on that device.
 */
static struct miscdevice miscProcessDevice = {
        .minor = MISC_DYNAMIC_MINOR,            // minor number
        .name = CHAR_DRIVER,                    // misc device
        .fops = &fops,                          // file operation function pointer assignment
};

#endif
